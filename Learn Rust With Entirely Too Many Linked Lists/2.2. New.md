# New

为了把实际代码关联到一个类型上，我们用`impl`块：

```rust
impl List {
    // TODO, make code happen
}
```

我们需要考虑如何编写代码。我们像这样声明一个函数：

```rust
fn foo(arg1: Type1, arg2: Type2) -> ReturnType {
    // body
}
```

最开始我们希望有一种方法用于*构建*一个 list。为了隐藏实现细节，我们需要提供一个函数。在 Rust 中通常的做法是提供一个静态方法，即一个位于`impl`中的普通的函数：

```rust
impl List {
    pub fn new() -> Self {
        List { head: Link::Empty }
    }
}
```

这里的一些注意点：

- Self 是“实现`impl`的类型”的一个别称。这样可以避免了重复。
- 我们创建一个结构体的实例与我们声明它类似，相比于为其字段提供类型，我们用值来初始化它。
- 我们使用`::`来指向一个枚举的成员，即命名空间操作符。
- 最后一个函数的表达式被隐式的返回。这样使得函数更加简洁。我们也可以像 C 类似的语言那样使用`return`作为返回。
