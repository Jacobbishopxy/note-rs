# 为什么异步？

我们都爱 Rust 赋予我们编写快速又安全软件的权利，但是异步编程是如何又是如何适应这一愿景的呢？

异步编程，简写 async，是一种并发编程模型，它被越来越多的语言所支持。它让你在少量的 OS 线程之间运行大量的并发任务，与此同时通过`async/await`语法来保持通常的同步编程的样式与感觉。

## Async vs 其它并发模型

并发编程相较于通常的顺序编程少了些成熟已经“标准化”。结果而言，我们表达并发的方式因为语言所提供的并发模型而异。下面是最流行的并发模型的一个简要总览，它可以帮助你理解异步编程是如何适用于更广泛的并发编程领域：

- OS 线程（OS threads）不需要对编程模型做任何改动，这就使得它可以非常简单的表达并发。然而，线程间的同步将会变得很困难，并且其性能开销很大。线程池可以缓解一些开销，但是还是不足以支持庞大的 IO-bound 工作负载。

- 事件驱动编程（Event-driven programming），由*callbacks*作为连接，可能表现出色，但是往往会变成冗余，“非线性”的控制流。数据流和错误传递通常难以跟踪。

- 协程（Coroutines），与线程类似，不需要改变编程模型，这使得他们可以简单的使用。与 async 类似，它们也可以支持大量的任务。然而他们抽象掉了底层细节，而这些正是系统编程语言和自定义实现运行时所需的重要关键。

- Actor 模型（The actor model）将所有并发计算分为 actor 单元，通过消息传递进行通信，这与分布式系统中的情况非常类似。actor 模型可以被非常有效的实现，但是它留下了很多未解决的实际问题，例如流控和重试逻辑。

总结来说，异步编程允许高性能的实现并且对与像 Rust 这样的 low-level 语言来说非常合适，同时也提供了线程和协程的大多数工程学优势。

## Rust 中的 Async vs 其它语言

尽管大多数语言都支持异步编程，一些细节缺是大相径庭的。Rust 的 async 实现在以下几种方式与其它语言截然不同：

- Rust 的 Futures 是惰性的，只用在轮询后才工作。丢弃一个 future 会停止其后续的工作。
- Rust 中的 async 是零消耗的，这意味着你只会为真实使用买单。具体来说你可以使用 async 而不占用堆分配和动态分发，这将大大的提高性能！这同样让你在受限的环境下使用 async，例如嵌入式系统。
- 不由 Rust 提供内置运行时，而是由社区所提供的库所提供。
- Rust 同时拥有单线程和多线程的运行时，意味着有不同的优缺点。

## Async vs Rust 中的线程

Rust 中用于替代异步的主要方案是 OS 线程，可以直接的通过`std::thread`或是间接的通过一个线程池来实现。由线程迁移到 async 或者相反的迁移通常需要大量的重构工作，无论是实现还是任何公有的接口。因此尽早的选择适合你的模型可以节省大量的开发时间。

**OS 线程**适用于少量的任务，因为线程带有 CPU 和内存开销。生成线程和在线程之间切换非常昂贵，因为即使空闲线程也会消耗系统资源。线程池可以减轻一些费用但并不是全部。然而线程可以让你重用现用的同步代码，不需要改变大量的代码--不需要特定的编程模型。在一些操作系统，你还可以更改线程的优先级，这对于驱动系统和其它对延时敏感的应用程序来说非常有用。

**Async**为 CPU 和内存提供了显著的性能提升，特别是对于大量的 IO-bound 任务而言，例如服务和数据库。在所有其它条件相同的情况下，你可以 OS 线程拥有更多数量级的任务，因为异步运行时使用少量（昂贵）线程来处理大量（廉价）任务。但是由于异步函数生成的状态机以及每个可执行文件都捆绑了一个异步运行时，异步 Rust 会导致更大的二进制 blob。

最后注意一点，异步编程并不是优于线程，而是不同于。如果出于性能原因你不需要 async，那么线程通常是更简单的选择。

### 案例：并发下载

这个例子的目的是并发下载两个网页。在通常线式的程应用程序我们需要生成线程来达到并发的目的：

```rs
fn get_two_sites() {
    // Spawn two threads to do work.
    let thread_one = thread::spawn(|| download("https://www.foo.com"));
    let thread_two = thread::spawn(|| download("https://www.bar.com"));

    // Wait for both threads to complete.
    thread_one.join().expect("thread one panicked");
    thread_two.join().expect("thread two panicked");
}
```

然而下载网页是小任务；为这种小任务来创建线程非常的浪费。对于大的应用程序而言，这会很快变成瓶颈。在异步 Rust 中，我们可以并发的运行这些任务而不需要额外的线程：

```rs
async fn get_two_sites_async() {
    // Create two different "futures" which, when run to completion,
    // will asynchronously download the webpages.
    let future_one = download_async("https://www.foo.com");
    let future_two = download_async("https://www.bar.com");

    // Run both futures to completion at the same time.
    join!(future_one, future_two);
}
```

这里没有创建额外的线程。另外所有的函数调用都是静态分发的，意味着没有堆分配！然而首先我们需要编写代码使其成为异步，这便是本书将帮助你达成的目标。

## 在 Rust 中自定义并发模型

最后注意一点，Rust 没有强迫你在线程和异步中进行选择。你可以在一个应用程序中同时使用它们，当你拥有混合线程和异步的依赖的时候，这会相当有用。实际上你甚至可以同时使用不同的并发模型，例如事件驱动编程，只要你能找到一个实现了它的库。
