# 异步 Rust 的状态

部分的异步 Rust 的支持与同步 Rust 一样稳定。其它部分还在持续完善，将会长时间持续改进。通过异步 Rust，你可以期望：

- 对于通常并发负载而言，拥有杰出的运行时性能
- 更频繁的与高级语言特性交互，例如生命周期和 pinning。
- sync 和 async 的代码之间，以及不同的异步运行时，它们都有一些兼容性的约束
- 更多的维护负担，因为异步运行时与语言支持正在不断发展

简言之相比于同步 Rust，异步 Rust 更难使用并且会导致高昂的维护负担，但是它给予你最好的性能输出。所有领域的异步 Rust 都在持续改善，所以随着时间流逝这些问题都将消失。

## 语言以及库的支持

虽然异步编程是被 Rust 所支持的，大多是异步应用依赖于社区所提供库的功能。因此你需要混合的依靠语言特性以及库支持：

- 最基础的特性，类型以及函数，例如 `Future` 特性是由标准库所提供的。
- `async/await` 语法是由 Rust 编译器直接提供的。
- 许多 utility 类型，宏和函数是由`futures`库所提供的。它们可以被用于任何异步 Rust 应用。
- async 代码的执行，IO 以及人物生成是由“异步运行时”所提供的，例如 Tokio 和 async-std。大多数异步应用程序，以及一些异步库，依赖于特定的运行时。之后在第八章将会细讲。

## 编译与调试

大多数情况下，编译时与运行时的错误在异步 Rust 与在同步 Rust 中表现的一致。有值的注意的区别：

### 编译时错误

异步 Rust 中的编译错误遵循与同步 Rust 所相同的高标准，但是由于异步 Rust 通常依赖于更复杂的语言功能，例如生命周期和 pinning，因此你可能会更频繁的遇到这些类型的错误。

### 运行时错误

每当编译器遇到异步函数时，它都会在后台生成状态机。异步 Rust 中的堆栈追踪通常包含这些状态机的详细信息以及运行时的函数调用。因此，与同步 Rust 相比，解释异步 Rust 的堆栈追踪可能要复杂的更多。

### 新失败模式

异步 Rust 中可能会出现一些新的失败模型，例如你从异步上下文中调用了阻塞函数，或者错误的实现`Future`特性。这些错误可以无声的通过编译，有时甚至可以通过单元测试。为了对底层概念有更深刻，本书将会帮助你避免这些陷阱。

## 兼容性的考量

异步和同步的代码不能总是自由组合。例如你不可以在一个同步函数中直接调用一个异步函数。同步和异步的代码还倾向于发展不同的设计模式，这可能使得难以编写用于不用环境的代码。

甚至异步代码也无法总是自由组合。一些库依赖于特定的异步运行时。如此它通常会指定库的依赖列表。

这些兼容性问题可能会限制你的选择，因此请确保尽早研究哪些异步运行时，以及你可能会用到的库。一旦在运行时都完成了，你便不在需要担心兼容性了。

## 性能的特点

异步 Rust 的性能取决于你所使用的异步运行时的实现。尽管为异步 Rust 应用程序锁提供支持的运行时相对年轻，但是对于大多数实际工作负载而言，它们的表现非常出色。

换言之，大多数异步生态系统都采用多线程运行时。这使得难以享受单线程异步应用程序的理论性能优势，即便宜的同步。另一个被忽略的用例是对延时敏感的任务，这对驱动程序，CUI 应用程序等很重要。这类任务取决于运行时和/或 OS 支持，一遍进行适当的调度。
