# Pinning

为了 poll futures，它们必须通过一个特殊的类型 `Pin<T>` 被钉下 pinned。如果你阅读过第二章的 `Future` 特性的解释，你将在 `Future::poll` 方法中认出 `self: Pin<&mut Self>` 中包含了 `Pin` 。

那么它是什么意思呢，以及为什么我们需要它？

## 为什么 Pinning

`Pin` 通过 `Unpin` 串联起来。Pinning 保证一个实现了 `!Unpin` 的对象不被移动。为了理解为什么这点是有必要的，我们需要记住 `async` / `.await` 是如何工作的。考虑如下代码：

```rs
let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
```

底层角度来看，这创建了一个实现了 `Future` 的匿名类型，提供一个 `poll` 方法如下：

```rs
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```

当 `poll` 第一次被调用，它将 poll `fut_one`。如果 `fut_one` 不能完成，`AsyncFuture::poll` 则作为返回。调用了 `poll` 的 future 将拾起上一次留下的。这个过程一直持续到 future 可以成功完成。

然而，如果我们有一个使用了引用的 `async` 块会发生什么呢？例如：

```rs
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```

这会编译成什么结构呢？

```rs
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```

这里 `ReadIntoBuf` future 持有一个引用进入另一个结构 `x` 的字段中。然而，如果 `AsyncFuture` 被移动， `x` 的地址也会被移动，便无效化了存储在 `read_into_buf_fut.buf` 的指针了。

Pinning future 与内存中特定的地址便可避免这个问题，让它可以在 `async` 块中安全的创建值的引用。

## Pinning 的细节

让我们尝试使用简单的案例来理解 pinning。在前面遇到的问题最终归结为我们如何在 Rust 中处理子应用类型中的引用问题。

我们的例子：

```rs
use std::pin::Pin;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

`Test` 提供了获取字段 `a` 和 `b` 值的引用的方法。因为 `b` 是一个 `a` 的引用，我们存储其为一个指针，因为借用规则，Rust 并不允许我们定义这个生命周期。我们现在拥有了一个被称为自引用的结构体了。

如果我们不移动任何数据你可以观察到我们的例子是能正常工作的：

```rs
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

结果如下：

```null
a: test1, b: test1
a: test2, b: test2
```

让我们看看如果交换 `test1` 与 `test2` 从而移动数据会发生什么：

```rs
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
```

我们可能会天真的认为结果如下：

```null
a: test1, b: test1
a: test1, b: test1
```

而实际上却是：

```null
a: test1, b: test1
a: test1, b: test2
```

`test2.b` 的指针仍然指向旧地址也就是现在还在 `test1` 内。结构体就再也不是自引用了，它持有了一个指向不同对象的指针。这就意味着我们不能依靠 `test2.b` 的生命周期来捆绑 `test2` 的生命周期了。

下面的图解可以帮助可视化问题：

![swap_problem](./swap_problem.jpg)

## Pinning 实践

让我们来看一下 pinning 和 `Pin` 类型是如何帮助我们解决这个问题的。

`Pin` 类型包裹了指针类型，保证指针后的值不会被移动。例如 `Pin<&mut T>`， `Pin<&T>`， `Pin<Box<T>>` 都保证了如果 `T: !Unpin`，`T` 不会被移动。

大多数类型的移动不会有问题。这些类型都实现了一个称为 `Unpin` 的特性。指向 `Unpin` 类型的指针可以从 `Pin` 中被自由的放入或是拿出。

然而，在它们被 pinned 之后拥有了一个称为 `!Unpin` 的标记，类型便不可再被移动。用 async/await 创建的 future 就是这样一个例子。

### Pinning 到栈上

回到我们的例子。我们可以通过 `Pin` 来解决问题。

```rs
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }
    fn init<'a>(self: Pin<&'a mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```

如果我们的类型实现了 `!Unpin`，pin 一个对象到栈上总是 `unsafe` 的。你也可以使用类似 `pin_utils` 的库来避免编写自己的 `unsafe` 代码。

以下是将 `test1` 与 `test2` pin 到栈上：

```rs
pub fn main() {
    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

现在如果我们尝试移动数据便会得到编译错误：

```rs
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
```

类型系统组织我们移动数据。

### Pinning 到堆上

pin 一个 `!Unpin` 类型到堆上给予我们数据一个稳定的地址，这样我们知道它在 pin 后就不可以再移动了。与栈的 pin 相反，我们知道被 pin 数据的对象的生命周期。

```rs
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a<'a>(self: Pin<&'a Self>) -> &'a str {
        &self.get_ref().a
    }

    fn b<'a>(self: Pin<&'a Self>) -> &'a String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

一些函数需要 future 带有 `Unpin` 才能工作。为了使用一个没有 `Unpin` 的 `Future` 或是 `Stream` 于一个需要 `Unpin` 类型的函数，你将首先通过 `Box::pin`（创建一个 `Pin<Box<T>>`）或者 `pin_utils::pin_mut!` 宏（创建一个 `Pin<&mut T>`）。`Pin<Box<Fut>>` 和 `Pin<&mut Fut>` 都可以用于 future，并且都实现了 `Unpin`。

例如：

```rs
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```

## 总结

1. 如果 `T: Unpin`（即默认），那么 `Pin<'a, T>` 就完全等同于 `&'a mut T`。也就是说：`Unpin` 意味着类型是可以移动的即使是在被 pin 住的时候，所以 `Pin` 对于这样的类型没有任何效果。
1. 如果 `T: !Unpin`，让一个 `&mut T` 成为被 pin 的 `T` 需要 unsafe。
1. 多数的标准库类型都实现了 `Unpin`。同样也适用于大多数 Rust 中的“正常”类型。一个由 async/await 生成的 `Future` 在这个规则之外。
1. 你可以添加一个 `!Unpin` 界限于一个类型（nightly Rust），或者在稳定版本 Rust 为类型添加 `std::marker::PhantomPinned`。
1. 你可以 pin 数据至栈或堆上。
1. Pin 一个 `!Unpin` 对象到栈上需要 `unsafe`。
1. Pin 一个 `!Unpin` 对象到堆上则不需要 `unsafe`。一个快捷方式便是使用 `Box::pin`。
1. 对被 pin 的数据 `T: !Unpin` ，你需要维持不变，即从 pin 到 drop 为止，其内存都不会失效或者被重新利用。这是 pin 合同的重要部分。
