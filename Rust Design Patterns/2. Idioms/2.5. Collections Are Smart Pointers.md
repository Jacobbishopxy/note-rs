# 集合皆为智能指针

## 描述

使用 `Deref` 特性如同智能指针那样对待集合，提供数据的所有权和借用。

## 案例

```rs
use std::ops::Deref;

struct Vec<T> {
    data: T,
    //..
}

impl<T> Deref for Vec<T> {
    type Target = [T];

    fn deref(&self) -> &[T] {
        //..
    }
}
```

一个 `Vec<T>` 是一个拥有 `T` 类型所有权的集合，一个切片（`&[T]`）是对于 `T` 集合的借用。为 `Vec` 实现 `Deref` 可以允许从 `&Vec<T>` 到 `&[T]` 的隐式解引用。你能想到的为 `Vec` 实现的多数方法实际上都是对切片实现的。

## 动机

所有权和借用是 Rust 的关键。数据结构必须遵循这些语法才能提供更好地用户体验。在实现一个包含数据的数据结构时，提供数据的借用可以允许更灵活的 API。

## 优点

大多方法仅可以为借用值实现，它们隐式的可用于所有权的借用。

这样给予用户可以对数据选择借用或是拥有。

## 缺点

边界检查时不考虑仅通过解引用可用的方法和特征，因此使用此模式的数据结构的泛型编程可能会变得复杂（例如 `Borrow` 和 `AsRef` 等特性）。

## 讨论

智能指针和集合类似：智能指针指向单个对象，而集合指向多个对象。从类型系统的角度来看，两者几乎没有区别。如果访问每个数据的唯一方式是通过集合并且集合负责删除数据（即使在共享所有权的情况下，某种借用可能是合适的），则集合拥有其数据。如果一个集合拥有其数据，那么提供一个借用数据通常很有用，使得它可以被多次引用。

多数智能指针（例如 `Foo<T>`）实现了 `Deref<Target=T>`。然而集合通常解引用成一个自定义类型。`[T]` 和 `str` 拥有一些语言支持，但是通常情况下，这是不必要的。`Foo<T>` 可以实现 `Deref<Target=Bar<T>>` 当 `Bar` 是动态大小的类型，同时 `&Bar<T>` 是对 `Foo<T>` 其中数据的借用时。

通常而言，有序集合会为 `Range` 实现 `Index` 用于提供切片语法。目标则是借用形式。
