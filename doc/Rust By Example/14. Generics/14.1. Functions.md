# 函数

同样的规则也作用于函数：当被`<T>`提前声明时一个类型`T`成为泛型。

有时使用泛型函数需要显式指定类型参数。这种情况一般都是当一个函数被调用时，其返回类型是通用的，或者编译器没有足够的信息用于推导必要的类型参数。

一个通过指定类型参数再被调用的函数像这样：`fun::<A, B, ...>()`。

```rust
struct A;          // 具体类型 `A`.
struct S(A);       // 具体类型 `S`.
struct SGen<T>(T); // 泛型 `SGen`.

// 以下所有函数都获取被传入的变量的所有权，并在离开作用域后立刻释放变量

// 定义一个 `reg_fn` 函数接受一个类型为 `S` 的入参 `_s`。
// 没有 `<T>` 因此不是泛型函数。
fn reg_fn(_s: S) {}

// 定义一个 `gen_spec_t` 函数接受一个类型为 `SGen<T>` 的入参 `_s`.
// 它被显式的给与了类型参数 `A`，但是因为 `A` 没有被指定为一个泛型类型参数，
// 该函数不是泛型函数。
fn gen_spec_t(_s: SGen<A>) {}

// 定义一个 `gen_spec_i32` 函数接受一个类型为 `SGen<i32>` 的入参 `_s`。
// 它被显式的给与了类型参数 `i32`，即一个指定的类型。
// 因为 `i32` 不是一个泛型类型，所以函数也不是泛型函数。
fn gen_spec_i32(_s: SGen<i32>) {}

// 定义一个 `generic` 函数接受一个类型为 `SGen<T>` 的入参 `_s`。
// 因为 `SGen<T>` 被 `<T>` 提前定义了，该函数是一个 `T` 泛型函数。
fn generic<T>(_s: SGen<T>) {}

fn main() {
    // 使用非泛型函数
    reg_fn(S(A));          // 具体类型
    gen_spec_t(SGen(A));   // 隐式指定类型参数 `A`
    gen_spec_i32(SGen(6)); // 隐式指定类型参数 `i32`

    // 显式为 `generic()` 指定类型参数 `char`
    generic::<char>(SGen('a'));

    // 隐式为 `generic()` 指定类型参数 `char`
    generic(SGen('c'));
}
```
