# 析构器的完善

## 描述

Rust 没有提供等同于 `finally` 块的支持 - 即无论函数如何退出都会被执行的代码。相对的，一个对象的析构器可以被用于编写在退出前必须执行的代码。

## 案例

```rs
fn bar() -> Result<(), ()> {
    // These don't need to be defined inside the function.
    struct Foo;

    // Implement a destructor for Foo.
    impl Drop for Foo {
        fn drop(&mut self) {
            println!("exit");
        }
    }

    // The dtor of _exit will run however the function `bar` is exited.
    let _exit = Foo;
    // Implicit return with `?` operator.
    baz()?;
    // Normal return.
    Ok(())
}
```

## 动机

如果一个函数有多个返回处，那么在退出时执行代码将变得困难以及重复（同样也是 bug 的温床）。尤其是宏产生的隐式返回。一个通常的情况是 `?` 操作符返回一个 `Err`，接着还有返回 `Ok`。`?` 用于错误处理机制中，但是不像 Java （它有 `finally`），没有任何方法调度使得代码可以执行在两种返回情况之后。panic 同样会导致函数提早退出。

## 优点

在析构器中的代码永远（大致上是）都会被执行 - panic，过早返回等等。

## 缺点

析构器的执行并不能被保证。例如，如果函数中有一个无限的循环或是函数在退出前就崩溃了。析构器也不能运行在一个已经 panic 线程中的 panic 下。因此在绝对需要终结处理的情况下，不能依赖析构器作为终结处理。

这个模式介绍了一些很难被注意的，隐式的代码。阅读一个函数并不能有一个明确的在退出时对析构器所运行的指引。这将使得 debug 变得困难。

需要一个对象以及其 `Drop` 实现作为终结处理的样板太过于沉重了。

## 讨论

如何存储作为终结器的对象比较微妙。它必须一直存活知道函数的结束然后再被摧毁。对象必须为一个值或唯一所有权的指针（例如 `Box<Foo>`）。如果使用的是一个共享指针（例如 `Rc`），那么终结器会持续存活并超出了函数的生命周期。同样的原因，终结器是不被允许移动或是返回的。

终结器必须分配给一个变量，否者它会被立刻摧毁，而不是在离开作用域时被摧毁。变量名称必须以 `_` 开头，如果变量仅仅作为终结器而使用，否者编译器会警告终结器从未被用到。然而，不要不带后缀就调用变量 `_` -- 这种情况下会被立刻摧毁。

在 Rust 中，析构器运行于对象离开作用域时。这发生在到达代码块的终点时，有一个早期的返回时，或是程序 panic 时。当 panic 时，Rust 解开栈并运行每个在栈上对象的析构器。因此析构器也是会在 panic 时被调用的。

如果在解开栈的时间内析构器发生 panic，没有好的处理方式，因此 Rust 则会立刻终止该线程，而不去运行其它的析构器。这就意味着析构器并不是完全保证能被运行的。同时也意味着你需要额外的小心你的析构器不要 panic，因为它可能会使资源处于意料之外的状态中。
