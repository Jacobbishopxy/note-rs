# 声明宏

```n
Syntax
MacroRulesDefinition :
   macro_rules ! IDENTIFIER MacroRulesDef

MacroRulesDef :
     ( MacroRules ) ;
   | [ MacroRules ] ;
   | { MacroRules }

MacroRules :
   MacroRule ( ; MacroRule )* ;?

MacroRule :
   MacroMatcher => MacroTranscriber

MacroMatcher :
     ( MacroMatch* )
   | [ MacroMatch* ]
   | { MacroMatch* }

MacroMatch :
     Tokenexcept $ and delimiters
   | MacroMatcher
   | $ IDENTIFIER : MacroFragSpec
   | $ ( MacroMatch+ ) MacroRepSep? MacroRepOp

MacroFragSpec :
     block | expr | ident | item | lifetime | literal
   | meta | pat | pat_param | path | stmt | tt | ty | vis

MacroRepSep :
   Tokenexcept delimiters and repetition operators

MacroRepOp :
   * | + | ?

MacroTranscriber :
   DelimTokenTree
```

`macro_rules` 允许用户以声明式的方式用于定义拓展的语法。我们称这样的拓展为“macros by example” 或者简称 “macros”。

每一个声明式的宏都有其名字，并带有一个或多个规则。每个规则都包含两个部分：一个 _matcher_ 匹配器，描述其匹配的语法，以及一个 _transcriber_ 转录器，描述成功匹配后用于替换的语法。匹配器和转换器都必须由分隔符围绕。

## Transcribing

当一个宏被调用，宏扩展器会通过名称来寻找宏，并且轮流尝试每个宏规则。它会转录第一个匹配的；如果这个结果错误，那么其余的匹配将不会再被尝试。匹配时不会有预判；如果编译器不能清晰的决定如何解析一个宏调用，那么返回错误。下面的例子中，编译器不会向前查看标识符其是否紧接着的是一个`)`，即便预判允许它明确的解析调用：

```rs
macro_rules! ambiguity {
    ($($i:ident)* $j:ident) => { };
}

ambiguity!(error); // Error: local ambiguity
```

匹配器和转换器中，`$` 符号用于从宏引擎（下面提到的 Metavariables 和 Repetitions）中调用特殊行为。不属于此类调用的符号将按字面进行匹配和转录。除了一个例外：匹配器外的外部的分隔符将匹配任何一对分隔符。因此例如匹配器 `(())` 将会匹配 `{()}` 而不是 `{{}}`。字符 `$` 不会被匹配或者字面转录。

当传递一个匹配的片段至另一个声明宏，位于第二个宏中的匹配器将看到这个片段的不完全抽象语法树 AST。第二个宏不能使用字面的字符来匹配匹配器中的片段，只能使用同一类型的片段分类符。`ident`，`lifetime` 以及 `tt` 片段类型是例外，它们可以被字面的字符匹配。下面例子阐述了这个限制：

```rs
fn main() {
macro_rules! foo {
    ($l:expr) => { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro_rules! bar {
    (3) => {}
}

foo!(3);
}
```

以下阐述字符是如何在匹配 `tt` 片段后被直接匹配的：

```rs
#![allow(unused)]
fn main() {
// compiles OK
macro_rules! foo {
    ($l:tt) => { bar!($l); }
}

macro_rules! bar {
    (3) => {}
}

foo!(3);
}
```

## Metavariables 元变量

在匹配器中，`$` _名字_ `:` _特定片段_ 匹配一个 Rust 语法片段，并将其绑定到元变量 `$` _名字_。有效的片段分类符有：

- `item`：一个项
- `block`：一个块状表达式
- `stmt`：一个声明，不带有分号（除非是需要分号的项）
- `pat_param`：PatternNoTopAlt
- `pat`：等同于 `pat_param`
- `expr`：一个表达式
- `ty`：一个类型
- `ident`：一个标识符或者关键字
- `path`：一个类型路径风格的路径
- `tt`：记号树（匹配分隔符 `()` `[]` `{}` 中的单个或多个记号）
- `meta`：属性，属性的内容
- `lifetime`：生命周期标记
- `vis`：可能为空的可见性标识符
- `literal`：匹配 “-” 字面表达式

在转录器中，元变量只需 `$` _名称_ 来进行引用，因为片段类型是在匹配器中指定的。元变量会被替换为其匹配的语法。关键字 `$crate` 可用于引用当前 crate；见下面的 Hygiene。元变量可被多次转换或者不转换。

### 重复

无论是匹配器还是转换器，通过将要重复的符号放在 `$(...)` 里，紧接着是一个重复操作符，它们直接也可以有一个分隔记号。分隔记号可以是任何符号，除了一个分隔符或某个重复运算符，而分号 `;` 和逗号 `,` 是最常用的。例如，`$( $i:ident ),*` 代表着任意数量的标识符通过逗号分隔。允许嵌套的表达。

重复操作符有：

- `*` 代表任意数量的重复
- `+` 代表至少一个任意数量的重复
- `?` 代表一个可选片段，允许零次或一次出现

由于 `?` 代表最多一次出现，它不可以被用于作为一个分隔记号。

重复的片段同时匹配与转录成指定数量的片段，由分隔记号的符号所分隔。元变量被匹配到与其符合的每个重复匹配。例如上述 `$( $i:ident ),*` 的例子，会匹配 `$i` 与列表中的所有标识符。

在转录期间，额外的限制作用于重复过程，这样编译器可以知道如何正确的展开他们：

1. 元变量在转录器中必须与在匹配器中，拥有完全相同的数量、类型和重复嵌套顺序出现。因此对于匹配器 `$( $i:ident ).*` 而言，转录器 `=> { $i }, => { $( $( $i)* )* }` 和 `=> { $( $i )+ }` 是非法的，但是 `=> { $( $i );* }` 是正确的，并且用分号分隔的列表替换逗号分隔的标识符列表。
1. 在转录器中的每个重复里必须包含至少一个元变量来决定展开的次数。如果在同一个重复中出现了多个元变量，它们必须与片段的数量保持一致。例如，`( $( $i:ident ),* ; $( $j:ident ),* ) => (( $( ($i,$j) ),* ))` 是合法的，并展开成 `((a,d), (b,e), (c,f))`，但是 `(a, b, c; d, e)` 是非法的，因为数量不同。这个要求适用于嵌套重复的每一层。

### 作用域，导出与导入

因为历史原因，声明宏与项的作用域并不完全相同。宏有两种类型的作用域：文本作用域，基于路径的作用域。文本作用域基于源文件中声明的顺序，或者是跨越数个文件的，它是默认的作用域。接下来会详细讲解。而基于路径的作用域与项的工作方式完全一致。宏的作用域，导出与导入很大程度都是由属性所控制的。

当宏被非限定标识符调用时（不是多重路径的一部分），它会首先查找文本作用域。如果没有返回任何结果，接着便查找基于路径的作用域。如果宏名称限定为路径，则仅在基于路径的作用域中查找。

```rs
use lazy_static::lazy_static; // 基于路径的导入

macro_rules! lazy_static { // 文本定义
    (lazy) => {};
}

lazy_static!{lazy} // 首先查找文本作用域
self::lazy_static!{} // 基于路径的查找，忽略文本定义的宏，找到并导入
```

#### 文本作用域

文本作用域主要基于源码中声明的顺序，其工作方式类似于通过 `let` 声明的本地变量，只不过也适用于模块级别的作用域。当 `macro_rules!` 用作定义一个宏，宏定义后进入其作用域（由于名称是从调用位置查找的，因此它仍然可以递归使用），直到其周围的作用域--通常为模块--关闭为止。文本作用域可应用于子模块，甚至覆盖多个文件：

```rs
//// src/lib.rs
mod has_macro {
    // m!{} // Error: m is not in scope.

    macro_rules! m {
        () => {};
    }
    m!{} // OK: appears after declaration of m.

    mod uses_macro;
}

// m!{} // Error: m is not in scope.

//// src/has_macro/uses_macro.rs

m!{} // OK: appears after declaration of m in src/lib.rs
```

对一个宏定义多次并不是错误；最新的定义将会重影 shadowing 之前的宏声明。

```rs
#![allow(unused)]
fn main() {
macro_rules! m {
    (1) => {};
}

m!(1);

mod inner {
    m!(1);

    macro_rules! m {
        (2) => {};
    }
    // m!(1); // Error: no rule matches '1'
    m!(2);

    macro_rules! m {
        (3) => {};
    }
    m!(3);
}

m!(1);
}
```

宏可以在函数内部被定义并本地使用：

```rs
#![allow(unused)]
fn main() {
fn foo() {
    // m!(); // Error: m is not in scope.
    macro_rules! m {
        () => {};
    }
    m!();
}


// m!(); // Error: m is not in scope.
}
```

#### `macro_use` 属性

...
