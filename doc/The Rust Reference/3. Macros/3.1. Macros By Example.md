# 声明宏

```n
Syntax
MacroRulesDefinition :
   macro_rules ! IDENTIFIER MacroRulesDef

MacroRulesDef :
     ( MacroRules ) ;
   | [ MacroRules ] ;
   | { MacroRules }

MacroRules :
   MacroRule ( ; MacroRule )* ;?

MacroRule :
   MacroMatcher => MacroTranscriber

MacroMatcher :
     ( MacroMatch* )
   | [ MacroMatch* ]
   | { MacroMatch* }

MacroMatch :
     Tokenexcept $ and delimiters
   | MacroMatcher
   | $ IDENTIFIER : MacroFragSpec
   | $ ( MacroMatch+ ) MacroRepSep? MacroRepOp

MacroFragSpec :
     block | expr | ident | item | lifetime | literal
   | meta | pat | pat_param | path | stmt | tt | ty | vis

MacroRepSep :
   Tokenexcept delimiters and repetition operators

MacroRepOp :
   * | + | ?

MacroTranscriber :
   DelimTokenTree
```

`macro_rules` 允许用户以声明式的方式用于定义拓展的语法。我们称这样的拓展为“macros by example” 或者简称 “macros”。

每一个声明式的宏都有其名字，并带有一个或多个规则。每个规则都包含两个部分：一个 _matcher_ 匹配器，描述其匹配的语法，以及一个 _transcriber_ 转录器，描述成功匹配后用于替换的语法。匹配器和转换器都必须由分隔符围绕。

## Transcribing

当一个宏被调用，宏扩展器会通过名称来寻找宏，并且轮流尝试每个宏规则。它会转录第一个匹配的；如果这个结果错误，那么其余的匹配将不会再被尝试。匹配时不会有预判；如果编译器不能清晰的决定如何解析一个宏调用，那么返回错误。下面的例子中，编译器不会向前查看标识符其是否紧接着的是一个`)`，即便预判允许它明确的解析调用：

```rs
macro_rules! ambiguity {
    ($($i:ident)* $j:ident) => { };
}

ambiguity!(error); // Error: local ambiguity
```

匹配器和转换器中，`$` 符号用于从宏引擎（下面提到的 Metavariables 和 Repetitions）中调用特殊行为。不属于此类调用的符号将按字面进行匹配和转录。除了一个例外：匹配器外的外部的分隔符将匹配任何一对分隔符。因此例如匹配器 `(())` 将会匹配 `{()}` 而不是 `{{}}`。字符 `$` 不会被匹配或者字面转录。

当传递一个匹配的片段至另一个声明宏，位于第二个宏中的匹配器将看到这个片段的不完全抽象语法树 AST。第二个宏不能使用字面的字符来匹配匹配器中的片段，只能使用同一类型的片段分类符。`ident`，`lifetime` 以及 `tt` 片段类型是例外，它们可以被字面的字符匹配。下面例子阐述了这个限制：

```rs
fn main() {
macro_rules! foo {
    ($l:expr) => { bar!($l); }
// ERROR:               ^^ no rules expected this token in macro call
}

macro_rules! bar {
    (3) => {}
}

foo!(3);
}
```

以下阐述字符是如何在匹配 `tt` 片段后被直接匹配的：

```rs
#![allow(unused)]
fn main() {
// compiles OK
macro_rules! foo {
    ($l:tt) => { bar!($l); }
}

macro_rules! bar {
    (3) => {}
}

foo!(3);
}
```

## Metavariables 元变量

在匹配器中，`$` _名字_ `:` _特定片段_ 匹配一个 Rust 语法片段，并将其绑定到元变量 `$` _名字_。有效的片段分类符有：

- `item`：一个项
- `block`：一个块状表达式
- `stmt`：一个声明，不带有分号（除非是需要分号的项）
- `pat_param`：PatternNoTopAlt
- `pat`：等同于 `pat_param`
- `expr`：一个表达式
- `ty`：一个类型
- `ident`：一个标识符或者关键字
- `path`：一个类型路径风格的路径
- `tt`：记号树（匹配分隔符 `()` `[]` `{}` 中的单个或多个记号）
- `meta`：属性，属性的内容
- `lifetime`：生命周期标记
- `vis`：可能为空的可见性标识符
- `literal`：匹配 “-” 字面表达式
