# Unsafe Rust

这是一个严肃的，巨大的，复杂的，以及危险的主题。它非常的严肃，为此我写了关于它的[一整本书](https://doc.rust-lang.org/nightly/nomicon/)。

总而言之，只要允许调用其他语言，每种语言实际上都是不安全的，因为你可以用C来做一些随机的坏事情。对了：Java，Python，Ruby，Haskell...面对外部功能接口Foreign Function Interfaces（FFI），它们都是不安全的。

Rust通过分离自身成为两种语言来拥抱这个真理：Safe Rust与Unsafe Rust。到现在为止我们所学习的都是Safe Rust。它是100%完全安全的...除了它可以通过FFI来编写Unsafe Rust。

Unsafe Rust是Safe Rust的一个*超集*。它拥有与Safe Rust完全一样的语义与规则，同时你允许做一些*额外*的事情，它们是不安全的并可能导致可拍未定义行为。

...

主要的Unsafe工具我们将会使用的是*裸指针*raw pointers。裸指针基本上就是C的指针。它们没有内在的别名规则。它们没有生命周期。它们可以是null。它们可以是悬垂的。它们可以指向为初始化的内存。它们可以强制转换为整数。它们可以强制转换为不同的类型。可变性？直接转换。大概是什么都可以做，也意味着都有可能出错。

这是不好的东西，坦白来说永远不触碰它们会让你活的更开心。不幸的是，我们想要linked list，它很糟糕。意味着我们需要使用不安全指针。

有两种类型的裸指针：`*const T`和`*mut T`。这等同于C的`const T*`和`T*`，但是我们不关心C里的意义。你只能解引用一个`*const T`成为一个`&T`，但更像是一个变量的可变性，它仅像是防止错误的lint。大多数情况它意味着你必须首先转换一个`*const`成为`*mut`。尽管如果你实际上没有权限去修改指针的引用对象，你会遇到困难。

不管怎么说，我们获得了一个好印象。目前，`*mut T == &unchecked mut T`！
