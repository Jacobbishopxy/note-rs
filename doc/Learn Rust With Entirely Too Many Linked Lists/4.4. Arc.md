# Arc

使用不可变list的其中一个原因是为了在多线程间共享数据。毕竟共享可变状态是原罪，一个解决该问题的办法就是永远杀掉*可变*部分。

我们的list完全不是线程安全的。为了使其变得线程安全，我们需要*原子性*的引用计数。否者两个线程在尝试增加引用计数时，可能只有其中一个能成功。这样list将会很快的被释放！

为了获得线程安全，我们可以使用*Arc*。Arc与Rc完全相同，除了其引用计数是原子性的。当你不需要这个特性的时候，使用它会有些负担，所以Rust把这两者都暴露给了用户。我们的案例中为了得到线程安全，只需要用`std::sync::Arc`替换掉所有的Rc。仅此而已，我们便得到了线程安全。完成！

但是这产生了一个有趣的问题：我们是如何判断一个类型是否是线程安全的呢？我们会不小心弄错吗？

不！在Rust里，你不可能搞错线程安全！

原因是Rust的线程安全模型是有两个特性派生的：`Send`和`Sync`（TRPL第16.4）。

一个类型是*Send*，如果它能安全的*移动*到另一个线程去。一个类型是*Sync*，如果它能在线程间安全的共享数据。也就是说，如果`T`是Sync，`&T`是Send。在这个情况下Safe意味着它不可能导致数据竞争，（不要与更宽泛的*资源竞争*搞混淆）。

这两个是标记性特性，也就是说一种优美的方式告诉大家他们是完全没有接口的。你只能是Send或者不是。这是*其他*API可能需要的属性。如果一个类型不是Send，那么将它静态地发送到另一个线程是不可能的！

Send和Sync也是自动衍生的特性。与实现Copy相似，只需要为当前类型标注上即可。

几乎所有的类型都是Send和Sync的。大多数类型是Send因为他们完全拥有他们的数据。大多数类型是Sync因为唯一跨线程共享数据的方式是将其放入一个共享引用中，即使其变得不可变！

然而有一些特别的类型违反了这些属性：那些拥有*内部可变性*interior mutability。目前为止我们接触到的只有*继承可变性*inherited mutability（也称为外部可变性）：一个值的可变性是由其容器所继承下来的。也就是说，你不可以随意的修改不可变值中的字段。

内部可变性类型违反了上述原则：他们让你通过一个共享引用来进行修改。它们有两个主要的类：cells，其只作用于单线程上下文；锁，其作用于多线程上下文。显而易见，使用cells的开销更低。它们都是原子性的，即拥有类似锁的行为。

所以应该怎么对待Rc和Arc呢？它们为了本身的*引用计数*都用到了内部可变性。这个引用计数是被不同实例所共享的！Rc仅使用了一个cell，意味着它不是线程安全。Arc使用原子性操作，意味着其线程安全。当然了，你不可以仅把一个类型放入Arc就认为它是线程安全了。Arc与其它类型一样，仅仅是衍生了线程安全。
