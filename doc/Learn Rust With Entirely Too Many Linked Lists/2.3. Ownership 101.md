# Ownership 101

现在我们可以构建一个 list 了。我们通过“普通”（非静态）方法来实现。在 Rust 中，方法是一种特殊的函数因为它带有`self`参数，该参数没有声明类型：

```rust
fn foo(self, arg2: Type2) -> ReturnType {
    // body
}
```

有 3 种 self 的形态选择：`self`，`&mut self`以及`&self`。这三种形态对应着三种 Rust 里的所有权：

- `self` -- 值
- `&mut self` -- 可变引用
- `&self` -- 共享引用

值代表*真是*所有权。你可以对其做任何事情：移动它，摧毁它，改变它，或者通过一个引用把它借出去。当你通过值来传递，它*移动*到了新的地方。新的地方拥有该值，而旧的地方不再刻意访问它。因为这个原因，多数方法并不使用`self`。

一个可变引用代表着对一个值的临时*唯一访问*权，你并不拥有它。只要在操作完成时是处于有效的状态，你被允许对可变引用所有的值做任何事情。这意味着你实际上可以完全覆盖该值。一个特别有用的用例就是与其它的值*交换*，我们将会频繁的使用该用例。唯一的不可以做的事是一个`&mut`移出值后没有替代的。`&mut self`是一个很棒的方法用于改变`self`。

一个共享引用代表着对一个值的临时*共享访问*权，你并不拥有它。因为你需要共享访问，通常来说不允许任何修改。
