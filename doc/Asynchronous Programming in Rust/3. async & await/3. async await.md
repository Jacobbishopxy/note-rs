# `async` / `.await`

在第一章中，我们简略的看了一下 `async` / `.await`。本章将会更为细致的讨论 `async` / `.await`，解释它如何工作的以及 `async` 代码与传统的 Rust 代码有何区别。

`async` / `.await` 是 Rust 中的特殊语法，通过 yield 而非阻塞的方式，它使得控制当前线程，在等待的同时并允许其它代码继续运行，变为可能。

有两种主要的方式使用 `async`：`async fn` 与 `async` 块。两者都返回一个实现了 `Future` 特性的值：

```rs
// `foo()` returns a type that implements `Future<Output = u8>`.
// `foo().await` will result in a value of type `u8`.
async fn foo() -> u8 { 5 }

fn bar() -> impl Future<Output = u8> {
    // This `async` block results in a type that implements
    // `Future<Output = u8>`.
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
```

正如第一章所见，`async` 主体与其它 future 都是惰性的：它们不做任何事情直到运行它们。最通常的做法运行一个 `Future` 是使用 `.await`。`.await` 在一个 `Future` 上调用，则会尝试运行它至结束。如果 `Future` 被阻塞，则会 yield 当前线程。当可以取的更多进展时，`Future` 将被执行器捡起并恢复运行，解决 `.await` 。

## `async` 生命周期

不同于传统的函数，`async fn` 获取引用或者非 `'static` 参数时返回一个 `Future` 是被参数所限定的：

```rs
// This function:
async fn foo(x: &u8) -> u8 { *x }

// Is equivalent to this function:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
```

这就意味着从 `async fn` 返回的 future 必须在非 `'static` 参数存活时被 `.await`。通常情况下对 future 立刻进行 `.await` 不会有这个问题。然而如果存储 future 再发送给别的任务或是线程时，这将会是一个问题。

一个通常的解决方案是通过 _似参数引用_ 来转换一个 `async fn` 成为一个 `'static` future，带着调用和参数一起打包到一个 `async` 块中：

```rs
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    borrow_x(&x) // ERROR: `x` does not live long enough
}

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
```

通过移动参数进入 `async` 块中，我们拓展了其生命周期以匹配由 `good` 所返回的 `Future`。

## `async move`

`async` 块与闭包都允许 `move` 关键字，与通常的闭包相似。一个 `async move` 块会获得其引用变量的所有权，允许它超过当前作用域存活，但是放弃了共享给其它代码的能力：

```rs
/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{}", my_string);
    };

    let future_two = async {
        // ...
        println!("{}", my_string);
    };

    // Run both futures to completion, printing "foo" twice:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async move` block can access the same captured variable, since
/// captures are moved into the `Future` generated by the `async move` block.
/// However, this allows the `Future` to outlive the original scope of the
/// variable:
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{}", my_string);
    }
}
```

## `.await` 在一个多线程执行器

注意当使用了一个多线程的 `Future` 执行器，一个 `Future` 可能会在多个线程间移动，因此在 `async` 中使用的所有变量必须具备线程间移动的能力，因为任何 `.await` 都潜在的可能在一个新线程中返回结果。

这就意味着使用 `Rc`，`&RefCell` 或是其它任何没有实现 `Send` 特性的类型，包括引用的类型没有实现 `Sync` 特性，是不安全的。

同样的，使用了传统的非 future 锁的代码在 `.await` 中也不是一个好主意，因为会导致线程池锁死：一个任务获取了锁，`.await` yield 了执行器，允许其它任务尝试获取锁就导致了死锁。为了避免这个问题，应该在 `futures::lock` 中使用 `Mutex` 而不是 `std::sync`。
