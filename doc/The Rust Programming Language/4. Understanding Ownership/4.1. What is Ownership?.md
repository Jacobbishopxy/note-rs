# 什么是所有权

所有权是 Rust 的核心特性。

所有的程序在运行时都需要管理计算机的内存。一些有垃圾回收的语言会在程序运行时不断地检查不使用的内存；另一些语言需要显式的分配和释放内存。Rust 使用的第三种方法：内存通过所有权系统来管理，这些规则则会在编译时期被检查。

因为所有权对许多程序员来说是一个新的概念，因此是需要花一些时间来习惯它。好消息是一个 Rust 程序员对所有权系统越熟悉，那么他写的代码则会越安全和高效。

```null
栈和堆

在很多语言里，你不需要考虑栈和堆的问题。但是像Rust这样的系统编程语言，一个值在栈或是堆上能决定语言的行为以及你为何需要这样选择。...

栈和堆都是内存的一部分，并且在你代码运行时可用，但是他们的构成不同。栈以后进先出的方式储存值。...增加数据的方式叫做进栈，移除数据的方式叫做出栈。

所有保存于栈的数据必须要有一个已知的大小。而数据的大小不确定，或者大小会改变就必须储存与堆中。堆的组织性弱一些：当你放入数据至堆中，你请求了一定大小的空间。这时内存分配器在堆中找到一个足够大的空间，标记被使用并返回一个指针。这个过程称之为在对上分配内存，有时就叫分配。将数据推入栈中不是分配。因为指针是已知固定大小的，你可以将指针存储在栈上，但是当你需要实际数据时，你需要访问这个指针。

...

入栈比在堆上分配要快，因为分配器永远不需要寻找一个地方去存储新的数据；位置是永远在栈的顶端。而在堆上分配空间需要更多的工作，因为分配器必须首先寻找一个足够大的空间来存储数据，然后为下一次分配任务做准备。

访问在堆上的数据比访问在栈上的数据要慢这是因为你需要通过指针来访问。现代处理器当它们跳的越少它们则越快。...

当你回调一个函数，传递给函数的值（包括可能指向堆上数据的指针），以及函数的局部变量将会入栈。当函数结束时，这些值就出栈。

持续观察哪一部分的代码在堆上用了什么数据，减少重复在堆上的数据，然后清除在堆上不再使用的数据，这些问题就是所有权系统所处理的。只要理解了所有权，你便不会再需要经常考虑栈和堆的问题。明白了所有权的存在是为了管理堆数据，可以帮助理解为什么所有权要以这种方式工作。

```

## 所有权规则

首先让我们来看一下所有权的规则：

- 在 Rust 中的一切值都有一个叫做所有者*owner*的变量
- 同一时期的值只允许有一个*owner*
- 当所有者*owner*离开了作用域，值将会被删除

## 变量作用域

...

第一个所有权的例子，我们看一下某些变量的作用域。一个作用域是一个值的有效范围：

```rust
let s = "hello";
```

变量`s`绑定了一个字符串。这个值在它被声明后直到作用域最后，都是有效的：

```rust
    {                      // s 无效，因为没有被声明
        let s = "hello";   // s 从声明处开始有效

        // 这儿做一些关于s的事儿
    }                      // 作用域在这里结束，s 无效了
```

...

## 字符串类型

...我们需要看一个 Rust 如何清理一个储存于堆的数据。

...

我们由`from`函数创建一个`String`：

```rust
let s = String::from("hello");
```

一个双冒号（`::`）的运算符让我们把这个特定的`from`函数放置于`String`类型的命名空间。

这类型的字符串也可以被修改：

```rust
    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() appends a literal to a String

    println!("{}", s); // This will print `hello, world!`
```

## 内存和分配

对于字面字符串而言，我们在编译时知道其内容，所以文本是直接硬编码进最终的可执行文件中。这是为什么字面字符串快速并有效。但是这些都是由字符串的不可变性带来的。然而，我们不能为了每一个在编译时未知大小的文本而将一块内存放入二进制文件中，并且其大小还可以在运行时改变。

对于`String`类型，为了支持可变性，可增长的文本，我们需要在堆上分配一定的内存（在编译时未知大小的内存用于存放数据）。也就是说：

- 必须在运行时向操作系统请求内存
- 需要一个当我们处理完`String`时，将内存返回给操作系统的方法

第一步已经由我们做好了：当我们调用`String::from`时，它请求了其需要的内存。这也是大多数语言所做的事。

然而第二步就不同了。在有垃圾回收（GC）的语言中，GC 持续关注并且清理内存，因此我们不需要考虑内存释放。没有 GC 的语言，我们的责任是需要自己识别不使用的内存，并显式的释放它们。...

Rust 使用了一个不同的方法：一旦变量离开了其作用域，变量的内存自动释放。这是一个使用`String`的例子：

```rust
    {
        let s = String::from("hello"); // s有效

        // 这儿做些关于s的事儿
    }                                  // 作用域结束，s不再有效
```

...

这种模式对于写 Rust 代码有一种深远的影响。它现在看起来很简单，但是当代码在更复杂的场景下这将会变得难以预测，比如我们有多个变量使用堆上分配的内存。

### 变量与数据交互的方式：移动

Rust 有多种方法使多个变量可以与同一个数据进行交互：

```rust
let x = 5;
let y = x;
```

我们大致可以猜到：“绑定数值`5`至`x`，然后拷贝`x`的值在绑定到`y`”。我们有两个变量，`x`和`y`，它们都等于`5`。这也是事实上发生的，因为整数是已知固定大小的简单值，所以这两个`5`都被放入了栈中。

现在看一下`String`：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

看上去与上面的代码类似，实际上的运作机制并不完全是这样的。

如图示，左侧为一个`String`由三部分组成，一个指向存放字符串内容的内存的指针，一个长度，一个容量。这一组数据存储于栈上。右侧为堆上存放内容的内存。

![p1](trpl04-01.svg)

`String`的长度表明其内容占用了多少字节的内存。`String`的容量表明从操作系统总共获取了多少字节的内存。长度和容量的区别很重要，不过现在暂时忽略。

当`s1`赋值给`s2`，`String`的数据被拷贝，意思是我们从栈上拷贝了指针，长度和容量。我们并没有拷贝指针指向的堆上的数据。如下图所示：

![p2](trpl04-02.svg)

如果 Rust 也拷贝了堆上的数据，那么内存看起来就如下图所示。如果 Rust 这么做了，那么`s2 = s1`会对运行时的性能造成非常大的影响：

![p3](trpl04-03.svg)

之前我们说当一个变量离开了作用域，Rust 会自动调用`drop`函数并清理变量在堆上的内存。实际上之前的两个指针指向了同一个位置。这就有了一个问题：当`s2`和`s1`离开作用域，他们会尝试释放相同的内存。也叫作二次释放的错误，这也是内存安全的 bug 之一。释放同样的内存两次会导致内存污染，可能会导致潜在的安全漏洞。

为了保证内存安全，Rust 还有一个细节需要注意。与其尝试拷贝被分配的内存，Rust 会认为`s1`不再有效，因此 Rust 不需要释放任何内存当`s1`离开作用域。当你使用`s1`在`s2`创建之后，看看会发生什么；这不会成功：

```rust
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
```

你将会得到一个错误如下，因为 Rust 会阻止你使用无效的引用：

```null
$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:5:28
  |
2 |     let s1 = String::from("hello");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
```

...

这解决了我们的问题。只有`s2`有效，当其离开作用域，它将释放内存，结束。

另外，这里有一个隐式的设计选择：Rust 永远不会自动创建数据的“深拷贝”。因此任何自动的拷贝可以被认为对运行时性能影响很小

### 变量与数据交互的方式：克隆

如果我们真的需要深度拷贝`String`在堆上的数据，不仅是栈上的数据，我们可以使用一个通用的方法`clone`。我们将在第五章讨论语法。

```rust
    let s1 = String::from("hello");
    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
```

...

当你看到`clone`，你知道一些特定的代码将会被执行并且它们可能会很消耗性能。

### 只在栈上的数据：拷贝

```rust
    let x = 5;
    let y = x;

    println!("x = {}, y = {}", x, y);
```

上面的代码似乎与我们刚学习的矛盾。我们没有调用`clone`，但是`x`依然有效并且没有被移动到`y`。

这是因为像整数型这些在编译的时候就已经知道大小的类型都是被整个储存在栈上，所以拷贝它们的值是很快的。...

...

## 所有权和函数

传值给函数与变量的赋值在语义上相似。向函数传递值可能是移动或是复制，与赋值语句一样：

```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域

    takes_ownership(s);             // s 被移动进了函数
                                    // s 在这里无效了

    let x = 5;                      // x 进入作用域

    makes_copy(x);                  // x 被移动进了函数
                                    // 但是 i32 是 Copy 所以 x 可以继续使用

} // 这里 x 被先移出作用域，然后是 s。但是 s 的值已经被移走了，所以不会有操作。

fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里， some_string 移出作用域并调用 `drop` 方法，占用的内存被释放。

fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域，没有操作。
```

如果尝试在调用 `takes_ownership` 之后使用 `s`，Rust 会出现编译错误。静态检查让我们免于犯错。

## 返回值和作用域

返回值也可以转移所有权：

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership 移动它的返回值给 s1

    let s2 = String::from("hello");     // s2 进入作用域

    let s3 = takes_and_gives_back(s2);  // s2 被移动到 takes_and_gives_back 里，
                                        // 返回值移动给 s3
} // 这里，s3 移出作用域并被丢弃。s2 也被移出作用域，但是已经被移走，没有操作。
  // s1 移出作用域并被抛弃。

fn gives_ownership() -> String {             // gives_ownership 将返回值移动给调用它的函数

    let some_string = String::from("hello"); // some_string 进入作用域

    some_string                              // 返回 some_string 并移动给调用的函数
}

// takes_and_gives_back 将传入字符串并返回值
fn takes_and_gives_back(a_string: String) -> String { // a_string 进入作用域
    a_string  // 返回 a_string 并移动给调用的函数
}
```

变量的所有权每次都遵守相应的模式：赋值给另一个变量时移动它。当一个在堆上有数据的变量离开作用域，它的值会被`drop`清除，除非数据所有权被移动给另一个变量。

...

我们可以使用元组来返回多值：

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 返回字符串长度

    (s, length)
}
```

...
